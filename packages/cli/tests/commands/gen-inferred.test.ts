import { expect, test, describe, beforeEach, afterEach } from "vitest";
import { mkdir, writeFile, rm, readFile } from "node:fs/promises";
import { join } from "node:path";
import { genInferred } from "../../src/commands/gen-inferred.ts";
import { tmpdir } from "node:os";

describe("genInferred", () => {
	let testDir: string;
	let outDir: string;
	let schemasDir: string;

	beforeEach(async () => {
		// Create a temporary directory for test files
		testDir = join(tmpdir(), `prototypekit-inferred-test-${Date.now()}`);
		outDir = join(testDir, "output");
		schemasDir = join(testDir, "schemas");
		await mkdir(testDir, { recursive: true });
		await mkdir(outDir, { recursive: true });
		await mkdir(schemasDir, { recursive: true });
	});

	afterEach(async () => {
		// Clean up test directory
		await rm(testDir, { recursive: true, force: true });
	});

	test("generates inferred types from a simple schema", async () => {
		// Create a test schema file
		const schemaFile = join(schemasDir, "app.bsky.actor.profile.json");
		await writeFile(
			schemaFile,
			JSON.stringify(
				{
					lexicon: 1,
					id: "app.bsky.actor.profile",
					defs: {
						main: {
							type: "record",
							key: "self",
							record: {
								type: "object",
								properties: {
									displayName: {
										type: "string",
										maxLength: 64,
										maxGraphemes: 64,
									},
									description: {
										type: "string",
										maxLength: 256,
										maxGraphemes: 256,
									},
								},
							},
						},
					},
				},
				null,
				"\t",
			),
		);

		// Run the inferred command
		await genInferred(outDir, schemaFile);

		// Read the generated TypeScript file
		const outputFile = join(outDir, "app/bsky/actor/profile.ts");
		const content = await readFile(outputFile, "utf-8");

		// Verify the generated code structure
		expect(content).toContain("// Generated by prototypekit - DO NOT EDIT");
		expect(content).toContain("// Source: app.bsky.actor.profile");
		expect(content).toContain('import type { Infer } from "prototypekit"');
		expect(content).toContain('with { type: "json" }');
		expect(content).toContain("export type Profile = Infer<typeof schema>");
		expect(content).toContain("export const ProfileSchema = schema");
		expect(content).toContain(
			"export function isProfile(v: unknown): v is Profile",
		);
		expect(content).toContain('v.$type === "app.bsky.actor.profile"');
	});

	test("generates correct directory structure from NSID", async () => {
		// Create a test schema with nested NSID
		const schemaFile = join(schemasDir, "app.bsky.feed.post.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				id: "app.bsky.feed.post",
				defs: {
					main: {
						type: "record",
						key: "tid",
						record: {
							type: "object",
							properties: {
								text: { type: "string" },
							},
						},
					},
				},
			}),
		);

		await genInferred(outDir, schemaFile);

		// Verify the directory structure matches NSID
		const outputFile = join(outDir, "app/bsky/feed/post.ts");
		const content = await readFile(outputFile, "utf-8");

		expect(content).toBeTruthy();
		expect(content).toContain("export type Post = Infer<typeof schema>");
	});

	test("handles multiple schema files with glob patterns", async () => {
		// Create multiple schema files
		await writeFile(
			join(schemasDir, "app.bsky.actor.profile.json"),
			JSON.stringify({
				lexicon: 1,
				id: "app.bsky.actor.profile",
				defs: { main: { type: "record" } },
			}),
		);

		await writeFile(
			join(schemasDir, "app.bsky.feed.post.json"),
			JSON.stringify({
				lexicon: 1,
				id: "app.bsky.feed.post",
				defs: { main: { type: "record" } },
			}),
		);

		// Run with glob pattern
		await genInferred(outDir, `${schemasDir}/*.json`);

		// Verify both files were created
		const profileContent = await readFile(
			join(outDir, "app/bsky/actor/profile.ts"),
			"utf-8",
		);
		const postContent = await readFile(
			join(outDir, "app/bsky/feed/post.ts"),
			"utf-8",
		);

		expect(profileContent).toContain("export type Profile");
		expect(postContent).toContain("export type Post");
	});

	test("generates correct relative import path", async () => {
		// Create a deeply nested schema
		const schemaFile = join(schemasDir, "com.atproto.repo.createRecord.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				id: "com.atproto.repo.createRecord",
				defs: {
					main: {
						type: "procedure",
						input: { encoding: "application/json" },
					},
				},
			}),
		);

		await genInferred(outDir, schemaFile);

		// Read generated file and check the import path is relative
		const outputFile = join(outDir, "com/atproto/repo/createRecord.ts");
		const content = await readFile(outputFile, "utf-8");

		// The import should be relative to the generated file location
		expect(content).toContain('import schema from "');
		expect(content).toContain('.json" with { type: "json" }');
		// Should navigate up from com/atproto/repo/ to schemas/
		expect(content).toMatch(/import schema from ".*createRecord\.json"/);
	});

	test("generates proper type name from NSID", async () => {
		// Test various NSID formats
		const testCases = [
			{ id: "app.bsky.feed.post", expectedType: "Post" },
			{ id: "com.atproto.repo.createRecord", expectedType: "CreateRecord" },
			{ id: "app.bsky.actor.profile", expectedType: "Profile" },
			{
				id: "app.bsky.feed.searchPosts",
				expectedType: "SearchPosts",
			},
		];

		for (const { id, expectedType } of testCases) {
			const schemaFile = join(schemasDir, `${id}.json`);
			await writeFile(
				schemaFile,
				JSON.stringify({
					lexicon: 1,
					id,
					defs: { main: { type: "record" } },
				}),
			);

			const testOutDir = join(testDir, `out-${id}`);
			await mkdir(testOutDir, { recursive: true });
			await genInferred(testOutDir, schemaFile);

			const nsidParts = id.split(".");
			const outputFile = join(testOutDir, ...nsidParts) + ".ts";
			const content = await readFile(outputFile, "utf-8");

			expect(content).toContain(`export type ${expectedType}`);
			expect(content).toContain(`export const ${expectedType}Schema`);
			expect(content).toContain(`export function is${expectedType}`);
		}
	});

	test("handles schema without id gracefully", async () => {
		// Create an invalid schema without id
		const schemaFile = join(schemasDir, "invalid.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				defs: { main: { type: "record" } },
			}),
		);

		// Should not throw, but should skip the file
		await expect(genInferred(outDir, schemaFile)).resolves.not.toThrow();

		// Output directory should be empty or not contain generated files
		const files = await readFile(outDir, "utf-8").catch(() => null);
		expect(files).toBeNull();
	});

	test("handles schema without defs gracefully", async () => {
		// Create an invalid schema without defs
		const schemaFile = join(schemasDir, "invalid2.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				id: "app.test.invalid",
			}),
		);

		// Should not throw, but should skip the file
		await expect(genInferred(outDir, schemaFile)).resolves.not.toThrow();
	});

	test("processes array of schema patterns", async () => {
		// Create schemas in different directories
		const schemasDir1 = join(testDir, "schemas1");
		const schemasDir2 = join(testDir, "schemas2");
		await mkdir(schemasDir1, { recursive: true });
		await mkdir(schemasDir2, { recursive: true });

		await writeFile(
			join(schemasDir1, "app.one.json"),
			JSON.stringify({
				lexicon: 1,
				id: "app.one",
				defs: { main: { type: "record" } },
			}),
		);

		await writeFile(
			join(schemasDir2, "app.two.json"),
			JSON.stringify({
				lexicon: 1,
				id: "app.two",
				defs: { main: { type: "record" } },
			}),
		);

		// Run with array of patterns
		await genInferred(outDir, [
			`${schemasDir1}/*.json`,
			`${schemasDir2}/*.json`,
		]);

		// Verify both were generated
		const oneContent = await readFile(join(outDir, "app/one.ts"), "utf-8");
		const twoContent = await readFile(join(outDir, "app/two.ts"), "utf-8");

		expect(oneContent).toContain("export type One");
		expect(twoContent).toContain("export type Two");
	});

	test("generates code with all required components", async () => {
		// Create a comprehensive schema
		const schemaFile = join(schemasDir, "app.test.complete.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				id: "app.test.complete",
				defs: {
					main: {
						type: "record",
						key: "tid",
						record: {
							type: "object",
							required: ["text"],
							properties: {
								text: { type: "string", maxLength: 300 },
								tags: { type: "array", items: { type: "string" } },
							},
						},
					},
				},
			}),
		);

		await genInferred(outDir, schemaFile);

		const outputFile = join(outDir, "app/test/complete.ts");
		const content = await readFile(outputFile, "utf-8");

		// Check all required exports
		expect(content).toContain('import type { Infer } from "prototypekit"');
		expect(content).toContain("export type Complete = Infer<typeof schema>");
		expect(content).toContain("export const CompleteSchema = schema");
		expect(content).toContain(
			"export function isComplete(v: unknown): v is Complete",
		);

		// Check type guard implementation
		expect(content).toContain('typeof v === "object"');
		expect(content).toContain("v !== null");
		expect(content).toContain('"$type" in v');
		expect(content).toContain('v.$type === "app.test.complete"');

		// Check comments
		expect(content).toContain("// Generated by prototypekit - DO NOT EDIT");
		expect(content).toContain("// Source: app.test.complete");
		expect(content).toContain(
			"* Type-inferred from lexicon schema: app.test.complete",
		);
		expect(content).toContain("* The lexicon schema object");
		expect(content).toContain("* Type guard to check if a value is a Complete");
	});

	test("handles kebab-case and mixed-case NSID parts", async () => {
		// Test NSID with different casing
		const schemaFile = join(schemasDir, "app.test.myCustomType.json");
		await writeFile(
			schemaFile,
			JSON.stringify({
				lexicon: 1,
				id: "app.test.myCustomType",
				defs: { main: { type: "record" } },
			}),
		);

		await genInferred(outDir, schemaFile);

		const outputFile = join(outDir, "app/test/myCustomType.ts");
		const content = await readFile(outputFile, "utf-8");

		// Should convert to PascalCase
		expect(content).toContain("export type MyCustomType");
		expect(content).toContain("export const MyCustomTypeSchema");
		expect(content).toContain("export function isMyCustomType");
	});
});
