import { relative, dirname } from "node:path";

interface LexiconSchema {
	lexicon: number;
	id: string;
	defs: Record<string, unknown>;
}

export function generateInferredCode(
	schema: LexiconSchema,
	schemaPath: string,
	outdir: string,
): string {
	const { id } = schema;

	// Calculate relative import path from output file to schema file
	// We need to go from generated/{nsid}.ts to the original schema
	const nsidParts = id.split(".");
	const outputDir = dirname([outdir, ...nsidParts].join("/"));
	const relativeSchemaPath = relative(outputDir, schemaPath);

	// Generate a clean type name from the NSID
	const typeName = generateTypeName(id);

	return `// Generated by prototypekit - DO NOT EDIT
// Source: ${id}
import type { Infer } from "prototypekit";
import schema from "${relativeSchemaPath}" with { type: "json" };

/**
 * Type-inferred from lexicon schema: ${id}
 */
export type ${typeName} = Infer<typeof schema>;

/**
 * The lexicon schema object
 */
export const ${typeName}Schema = schema;

/**
 * Type guard to check if a value is a ${typeName}
 */
export function is${typeName}(v: unknown): v is ${typeName} {
	return (
		typeof v === "object" &&
		v !== null &&
		"$type" in v &&
		v.$type === "${id}"
	);
}
`;
}

function generateTypeName(nsid: string): string {
	// Convert app.bsky.feed.post -> Post
	// Convert com.atproto.repo.createRecord -> CreateRecord
	const parts = nsid.split(".");
	const lastPart = parts[parts.length - 1];

	// Convert kebab-case or camelCase to PascalCase
	return lastPart
		.split(/[-_]/)
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join("");
}
